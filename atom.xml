<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>斑斓的梦</title>
  <subtitle>Zhen&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://pzhen.github.io/"/>
  <updated>2017-08-01T07:23:49.000Z</updated>
  <id>http://pzhen.github.io/</id>
  
  <author>
    <name>P.Zhen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Html-漂亮的后台模板</title>
    <link href="http://pzhen.github.io/2017/08/01/Html-%E6%BC%82%E4%BA%AE%E7%9A%84%E5%90%8E%E5%8F%B0%E6%A8%A1%E6%9D%BF/"/>
    <id>http://pzhen.github.io/2017/08/01/Html-漂亮的后台模板/</id>
    <published>2017-08-01T07:22:17.000Z</published>
    <updated>2017-08-01T07:23:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>分享一个后台模板地址，喜欢的可以自己克隆。</p>
<p><a href="http://envato.stammtec.de/themeforest/melon/pages_user_profile.html" target="_blank" rel="external">http://envato.stammtec.de/themeforest/melon/pages_user_profile.html</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分享一个后台模板地址，喜欢的可以自己克隆。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://envato.stammtec.de/themeforest/melon/pages_user_profile.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;
    
    </summary>
    
      <category term="Html" scheme="http://pzhen.github.io/categories/Html/"/>
    
    
      <category term="Html" scheme="http://pzhen.github.io/tags/Html/"/>
    
      <category term="Template" scheme="http://pzhen.github.io/tags/Template/"/>
    
  </entry>
  
  <entry>
    <title>Tools-Vmware fusion 8.5 pro 注册码</title>
    <link href="http://pzhen.github.io/2017/08/01/Tools-Vmware-fusion-8-5-pro-%E6%B3%A8%E5%86%8C%E7%A0%81/"/>
    <id>http://pzhen.github.io/2017/08/01/Tools-Vmware-fusion-8-5-pro-注册码/</id>
    <published>2017-08-01T07:19:33.000Z</published>
    <updated>2017-08-01T07:20:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>FY7N2-6RGD2-081XZ-UYWQC-ZPKCA</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;FY7N2-6RGD2-081XZ-UYWQC-ZPKCA&lt;/p&gt;

    
    </summary>
    
      <category term="Tools" scheme="http://pzhen.github.io/categories/Tools/"/>
    
    
      <category term="Tools" scheme="http://pzhen.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Tools-Win8.1专业版秘钥</title>
    <link href="http://pzhen.github.io/2017/08/01/Tools-Window8-1%E4%B8%93%E4%B8%9A%E7%89%88%E6%9C%AC%E7%A7%98%E9%92%A5/"/>
    <id>http://pzhen.github.io/2017/08/01/Tools-Window8-1专业版本秘钥/</id>
    <published>2017-08-01T07:17:27.000Z</published>
    <updated>2017-08-01T07:18:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>XHQ8N  C3MCJ  RQXB6   WCHYG   C9WKB</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;XHQ8N  C3MCJ  RQXB6   WCHYG   C9WKB&lt;/p&gt;

    
    </summary>
    
      <category term="Tools" scheme="http://pzhen.github.io/categories/Tools/"/>
    
    
      <category term="Tools" scheme="http://pzhen.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Tools-XP注册码</title>
    <link href="http://pzhen.github.io/2017/08/01/Tools-XP%E6%B3%A8%E5%86%8C%E7%A0%81/"/>
    <id>http://pzhen.github.io/2017/08/01/Tools-XP注册码/</id>
    <published>2017-08-01T07:14:25.000Z</published>
    <updated>2017-08-01T07:14:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>QC986-27D34-6M3TY-JJXP9-TBGMD<br>CM3HY-26VYW-6JRYC-X66GX-JVY2D<br>DP7CM-PD6MC-6BKXT-M8JJ6-RPXGJ<br>F4297-RCWJP-P482C-YY23Y-XH8W3<br>HH7VV-6P3G9-82TWK-QKJJ3-MXR96<br>HCQ9D-TVCWX-X9QRG-J4B2Y-GR2TT<br>M6TF9-8XQ2M-YQK9F-7TBB2-XGG88<br>DG8FV-B9TKY-FRT9J-6CRCC-XPQ4G</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;QC986-27D34-6M3TY-JJXP9-TBGMD&lt;br&gt;CM3HY-26VYW-6JRYC-X66GX-JVY2D&lt;br&gt;DP7CM-PD6MC-6BKXT-M8JJ6-RPXGJ&lt;br&gt;F4297-RCWJP-P482C-YY23Y-XH8W3&lt;br&gt;HH7VV
    
    </summary>
    
      <category term="Tools" scheme="http://pzhen.github.io/categories/Tools/"/>
    
    
      <category term="Tools" scheme="http://pzhen.github.io/tags/Tools/"/>
    
      <category term="注册码" scheme="http://pzhen.github.io/tags/%E6%B3%A8%E5%86%8C%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Funny-书生拿着书在打瞌睡</title>
    <link href="http://pzhen.github.io/2017/08/01/Funny-%E4%B9%A6%E7%94%9F%E6%8B%BF%E7%9D%80%E4%B9%A6%E5%9C%A8%E6%89%93%E7%9E%8C%E7%9D%A1/"/>
    <id>http://pzhen.github.io/2017/08/01/Funny-书生拿着书在打瞌睡/</id>
    <published>2017-08-01T07:08:03.000Z</published>
    <updated>2017-08-01T07:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>书生拿着书在打瞌睡。<br>欣赏他的人说，你瞧，他多用功，睡着了还拿着书。<br><a id="more"></a><br>不欣赏他的人说，你瞧，他多懒惰，一拿着书就睡着了。<br>看的人不同了，书生就不是那个书生了。<br>你爱他的时候，他的缺点都是优点，你不爱他了，他的优点也成了缺点。<br>看的眼光不同了，他就不是他了。<br>和一个人牵手的时候，就以为会是一生一世的相守。等到隔着太长的一段心路望回来，才惊讶地发现，虽然彼此都那么熟悉地活在彼此身边，却连相互述说的欲望都已经没有。是的，冷眼旁观着，彼此都在不知不觉中成了河川。而河川，永远都只会觉得是对方这座桥在走。<br>     一则佛教故事。<br>从前有个书生, 和未婚妻约好在某年某月某日结婚。到那一天，未婚妻却嫁给了别人。书生受此打击, 一病不起。这时, 路过一游方僧人，从怀里摸出一面镜子叫书生看……<br>书生看到茫茫大海，一名遇害的女子一丝不挂地躺在海滩上。路过一人, 看一眼，摇摇头, 走了。又路过一人, 将衣服脱下,给女尸盖上, 走了。再路过一人,过去, 挖个坑, 小心翼翼把尸体掩埋了。<br>僧人解释道, 那具海滩上的女尸，就是你未婚妻的前世。你是第二个路过的人，曾给过他一件衣服，她今生和你相恋, 只为还你一个情。但是她最终要报答一生一世的人, 是最后那个把她掩埋的人, 那人就是他现在的丈夫。<br>书生大悟。</p>
<p>前世，究竟是谁埋了你？<br>金岳霖找到了林徽因。他用一生的孤独来回报林徽因这位前世埋了他的人。<br>徐志摩找到了谁？“我将于茫茫人海中访我唯一灵魂的伴侣，得之，我幸；不得，我命。如此而已。”这是他在追求陆小曼时说的话。他轻轻地从林徽因的身边走了，正如他轻轻地 来，他轻轻地挥手，没有带走林身边的一朵云彩。为了满足陆奢靡的生活，他频繁的往来于南北授课，在碧蓝的天空中，他把他34岁的生命回报给了前世埋他的陆小曼。<br>人们从奈何桥上匆匆走过。<br>孟婆说：“行路的人，喝碗孟婆汤解解渴。”口渴的人心急地喝了。于是，那个前世埋他们的人，在他们头脑中渐渐模糊了。他们开始惊惶地四处张望，妄图在茫茫 人海中寻找今生的爱人。“众里寻它千百度，蓦然回首，那人却在灯火阑珊处。”其实，你携起他的手时，就是前世残存的记忆在提醒你了，前世埋你的人，就是你 身边与你相濡以沫的爱人啊。<br>     欣赏那个打瞌睡的书生吧。他真的很用功，你瞧，他睡着了还拿着书呢。<br>月光下的大海，泛着粼粼的波。<br>朋友说，思涵，和你的爱人去看看月光下的大海吧，在大海的最深处，也许就藏着你前生的记忆呢。<br>我在屏幕前轻轻的笑了。三生石上的旧精魂，真的不是一个美丽的传说么？与前世埋过我的爱人，携手在银色的沙滩，那该是今生最完美的一种幸福了吧。<br>我从奈何桥上走过，孟婆说：“行路的人，喝碗孟婆汤解解渴。”不，不不，我不喝，我宁愿在忘川河边忍受水淹火炙的磨折，我也一定要记得，前世，是谁埋的我……<br>     前世，究竟是谁埋了我…… </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书生拿着书在打瞌睡。&lt;br&gt;欣赏他的人说，你瞧，他多用功，睡着了还拿着书。&lt;br&gt;
    
    </summary>
    
      <category term="Funny" scheme="http://pzhen.github.io/categories/Funny/"/>
    
    
      <category term="Funny" scheme="http://pzhen.github.io/tags/Funny/"/>
    
  </entry>
  
  <entry>
    <title>Arithmetic-一致性Hash</title>
    <link href="http://pzhen.github.io/2017/08/01/Arithmetic-%E4%B8%80%E8%87%B4%E6%80%A7Hash/"/>
    <id>http://pzhen.github.io/2017/08/01/Arithmetic-一致性Hash/</id>
    <published>2017-08-01T06:43:30.000Z</published>
    <updated>2017-08-01T06:52:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。 </p>
<p>一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：</p>
<ul>
<li>1、平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</li>
<li>2、单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 </li>
<li>3、分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 </li>
<li>4、负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</li>
</ul>
<p>在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这样严重的违反了单调性原则。接下来主要讲解一下一致性哈希算法是如何设计的：</p>
<h3 id="环形Hash空间"><a href="#环形Hash空间" class="headerlink" title="环形Hash空间"></a>环形Hash空间</h3><p>按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图<br><img src="20140411000507734.png" alt=""></p>
<h3 id="把数据通过一定的hash算法处理后映射到环上"><a href="#把数据通过一定的hash算法处理后映射到环上" class="headerlink" title="把数据通过一定的hash算法处理后映射到环上"></a>把数据通过一定的hash算法处理后映射到环上</h3><p>现在我们将object1、object2、object3、object4四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。如下图：</p>
<pre><code>Hash(object1) = key1；
Hash(object2) = key2；
Hash(object3) = key3；
Hash(object4) = key4；
</code></pre><p><img src="20140411000620656.png" alt=""></p>
<h3 id="将机器通过hash算法映射到环上"><a href="#将机器通过hash算法映射到环上" class="headerlink" title="将机器通过hash算法映射到环上"></a>将机器通过hash算法映射到环上</h3><p>在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。<br>假设现在有NODE1，NODE2，NODE3三台机器，通过Hash算法得到对应的KEY值，映射到环中，其示意图如下：</p>
<pre><code>Hash(NODE1) = KEY1;
Hash(NODE2) = KEY2;
Hash(NODE3) = KEY3;
</code></pre><p><img src="20140411000853609.png" alt=""></p>
<p>通过上图可以看出对象与机器处于同一哈希空间中，这样按顺时针转动object1存储到了NODE1中，object3存储到了NODE2中，object2、object4存储到了NODE3中。在这样的部署环境中，hash环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。</p>
<h3 id="机器的删除与添加"><a href="#机器的删除与添加" class="headerlink" title="机器的删除与添加"></a>机器的删除与添加</h3><p>普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。</p>
<h4 id="1-节点（机器）的删除"><a href="#1-节点（机器）的删除" class="headerlink" title="1. 节点（机器）的删除"></a>1. 节点（机器）的删除</h4><p>以上面的分布为例，如果NODE2出现故障被删除了，那么按照顺时针迁移的方法，object3将会被迁移到NODE3中，这样仅仅是object3的映射位置发生了变化，其它的对象没有任何的改动。如下图：<br><img src="20140411001033656.png" alt=""></p>
<h4 id="2-节点（机器）的添加"><a href="#2-节点（机器）的添加" class="headerlink" title="2. 节点（机器）的添加"></a>2. 节点（机器）的添加</h4><p>如果往集群中添加一个新的节点NODE4，通过对应的哈希算法得到KEY4，并映射到环中，如下图：<br><img src="20140411001211062.png" alt="">    </p>
<p>通过按顺时针迁移的规则，那么object2被迁移到了NODE4中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</p>
<h3 id="平衡性"><a href="#平衡性" class="headerlink" title="平衡性"></a>平衡性</h3><p>根据上面的图解分析，一致性哈希算法满足了单调性和负载均衡的特性以及一般hash算法的分散性，但这还并不能当做其被广泛应用的原由，因为还缺少了平衡性。下面将分析一致性哈希算法是如何满足平衡性的。hash算法是不保证平衡的，如上面只部署了NODE1和NODE3的情况（NODE2被删除的图），object1存储到了NODE1中，而object2、object3、object4都存储到了NODE3中，这样就照成了非常不平衡的状态。在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点。<br>——“虚拟节点”（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ），一实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列。<br>以上面只部署了NODE1和NODE3的情况（NODE2被删除的图）为例，之前的对象在机器上的分布很不均衡，现在我们以2个副本（复制个数）为例，这样整个hash环中就存在了4个虚拟节点，最后对象映射的关系图如下：</p>
<p><img src="20140411001433375.png" alt=""><br>根据上图可知对象的映射关系：object1-&gt;NODE1-1，object2-&gt;NODE1-2，object3-&gt;NODE3-2，object4-&gt;NODE3-1。通过虚拟节点的引入，对象的分布就比较均衡了。那么在实际操作中，正真的对象查询是如何工作的呢？对象从hash到虚拟节点到实际节点的转换如下图：<br><img src="20140411001540656.png" alt=""><br>“虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设NODE1的IP地址为192.168.1.100。引入“虚拟节点”前，计算 cache A 的 hash 值：<br>Hash(“192.168.1.100”);<br>引入“虚拟节点”后，计算“虚拟节”点NODE1-1和NODE1-2的hash值：<br>Hash(“192.168.1.100#1”); // NODE1-1<br>Hash(“192.168.1.100#2”); // NODE1-2</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。
    
    </summary>
    
      <category term="Arithmetic" scheme="http://pzhen.github.io/categories/Arithmetic/"/>
    
    
      <category term="Arithmetic" scheme="http://pzhen.github.io/tags/Arithmetic/"/>
    
  </entry>
  
  <entry>
    <title>Funny-你笑了吗?</title>
    <link href="http://pzhen.github.io/2017/08/01/Funny-%E4%BD%A0%E7%AC%91%E4%BA%86%E5%90%97/"/>
    <id>http://pzhen.github.io/2017/08/01/Funny-你笑了吗/</id>
    <published>2017-08-01T06:17:15.000Z</published>
    <updated>2017-08-01T07:06:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>小漫画大道理<br><a id="more"></a></p>
<p><img src="5459032_4.jpg" alt=""><br><img src="5459032_5.jpg" alt=""><br><img src="5459032_6.jpg" alt=""><br><img src="5459032_7.jpg" alt=""><br><img src="5459032_8.jpg" alt=""><br><img src="5459032_9.jpg" alt=""><br><img src="5459032_10.jpg" alt=""><br><img src="5459032_11.jpg" alt=""><br><img src="5459032_12.jpg" alt=""><br><img src="5459032_13.jpg" alt=""><br><img src="5459032_14.jpg" alt=""><br><img src="5459032_15.jpg" alt=""><br><img src="5459032_16.jpg" alt=""><br><img src="5459032_17.jpg" alt=""><br><img src="5459032_18.jpg" alt=""><br><img src="5459032_19.jpg" alt=""><br><img src="5459032_20.jpg" alt=""><br><img src="5459032_21.jpg" alt=""><br><img src="5459032_22.jpg" alt=""><br><img src="5459032_23.jpg" alt=""><br><img src="5459032_24.jpg" alt=""><br><img src="5459032_25.jpg" alt=""><br><img src="5459032_26.jpg" alt=""><br><img src="5459032_27.jpg" alt=""><br><img src="5459032_28.jpg" alt=""><br><img src="5459032_29.jpg" alt=""><br><img src="5459032_30.jpg" alt=""><br><img src="5459032_31.jpg" alt=""><br><img src="5459032_32.jpg" alt=""><br><img src="5459032_33.jpg" alt=""><br><img src="5459032_34.jpg" alt=""><br><img src="5459032_35.jpg" alt=""><br><img src="5459032_36.jpg" alt=""><br><img src="5459032_37.jpg" alt=""><br><img src="5459032_38.jpg" alt=""><br><img src="5459032_39.jpg" alt=""><br><img src="5459032_40.jpg" alt=""><br><img src="5459032_41.jpg" alt=""><br><img src="5459032_42.jpg" alt=""><br><img src="5459032_43.jpg" alt=""><br><img src="5459032_44.jpg" alt=""><br><img src="5459032_45.jpg" alt=""><br><img src="5459032_46.jpg" alt=""><br><img src="5459032_47.jpg" alt=""><br><img src="5459032_48.jpg" alt=""><br><img src="5459032_49.jpg" alt=""><br><img src="5459032_50.jpg" alt=""><br><img src="5459032_51.jpg" alt=""><br><img src="5459032_52.jpg" alt=""><br><img src="5459032_53.jpg" alt=""><br><img src="5459032_54.jpg" alt=""><br><img src="5459032_56.jpg" alt=""><br><img src="5459032_55.jpg" alt=""><br><img src="5459032_1.jpg" alt=""><br><img src="5459032_2.jpg" alt=""><br><img src="5459032_3.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小漫画大道理&lt;br&gt;
    
    </summary>
    
      <category term="Funny" scheme="http://pzhen.github.io/categories/Funny/"/>
    
    
      <category term="Funny" scheme="http://pzhen.github.io/tags/Funny/"/>
    
  </entry>
  
  <entry>
    <title>Funny-小漫画大道理</title>
    <link href="http://pzhen.github.io/2017/08/01/Funny-%E5%B0%8F%E6%BC%AB%E7%94%BB%E5%A4%A7%E9%81%93%E7%90%86/"/>
    <id>http://pzhen.github.io/2017/08/01/Funny-小漫画大道理/</id>
    <published>2017-08-01T05:53:52.000Z</published>
    <updated>2017-08-01T06:04:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小猫咪的哲理人生"><a href="#小猫咪的哲理人生" class="headerlink" title="小猫咪的哲理人生"></a>小猫咪的哲理人生</h1><a id="more"></a>
<p><img src="p1zz9771rfsd.jpg" alt="1"><br><img src="59gx9o4dks5c.jpg" alt="2"><br><img src="5dc5k5vz56sf.jpg" alt="3"><br><img src="s72u3edi6e7f.jpg" alt="4"><br><img src="a2oa2xxc57a1.jpg" alt="5"><br><img src="df44ergr2ess.jpg" alt="6"><br><img src="djj2xxqxdjx5.jpg" alt="7"><br><img src="mh67e2j7lo7y.jpg" alt="8"><br><img src="3uqls0l200zz.jpg" alt="9"><br><img src="wlj7rl3fj5cg.jpg" alt="10"><br><img src="rlr4l5xrdsrh.jpg" alt="11"><br><img src="1wv75v8iyww8.jpg" alt="12"><br><img src="jjnj24r456pp.jpg" alt="13"><br><img src="p8bdooodoso2.jpg" alt="14"><br><img src="kny4arhkynkn.jpg" alt="15"><br><img src="duuzdepltpdy.jpg" alt="16"><br><img src="a2dzq46dzxx2.jpg" alt="17"><br><img src="iccnyttyu9cf.jpg" alt="18"><br><img src="6844aa44taff.jpg" alt="19"><br><img src="ojj8rrfruqy2.jpg" alt="20"><br><img src="txmxihh6dxjq.jpg" alt="21"><br><img src="gbgd7q1uqgtt.jpg" alt="22"><br><img src="mb0lmvbmmlol.jpg" alt="23"><br><img src="r6h4dwy3wyr8.jpg" alt="24"><br><img src="z28c2fgtvceb.jpg" alt="25"><br><img src="fzxxkq1nkkvk.jpg" alt="26"><br><img src="8lrt3xkbka69.jpg" alt="27"><br><img src="enqeq7e75cey.jpg" alt="28"><br><img src="e5muqxqqsxu.jpeg" alt="29"><br><img src="ncec00mderdz.jpg" alt="30"><br><img src="f5axrqz7y64y.jpg" alt="31"><br><img src="gpfrrrsjyrzr.jpg" alt="32"><br><img src="t6stytzm5tky.jpg" alt="33"><br><img src="we50g5dupurd.jpg" alt="34"><br><img src="1zwqbh73iwde.jpg" alt="35"><br><img src="k2o9x5seyezi.jpg" alt="36"><br><img src="sl6zm2l1e11w.jpg" alt="37"><br><img src="ucuov79hs5u0.jpg" alt="38"><br><img src="no0didd33nss.jpg" alt="39"><br><img src="s62kz5j2mt25.jpg" alt="40"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;小猫咪的哲理人生&quot;&gt;&lt;a href=&quot;#小猫咪的哲理人生&quot; class=&quot;headerlink&quot; title=&quot;小猫咪的哲理人生&quot;&gt;&lt;/a&gt;小猫咪的哲理人生&lt;/h1&gt;
    
    </summary>
    
      <category term="Funny" scheme="http://pzhen.github.io/categories/Funny/"/>
    
    
      <category term="Funny" scheme="http://pzhen.github.io/tags/Funny/"/>
    
  </entry>
  
  <entry>
    <title>Mem-内存管理原理</title>
    <link href="http://pzhen.github.io/2017/08/01/Memcached-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86/"/>
    <id>http://pzhen.github.io/2017/08/01/Memcached-内存管理原理/</id>
    <published>2017-08-01T05:24:08.000Z</published>
    <updated>2017-08-01T05:34:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>内存管理中一个令人头痛的问题就是内存碎片管理。操作系统、虚拟机垃圾回收在这方面<br>想了许多方法：压缩、复制。Memcached使用了一个非常简单的办法—固定空间分配。</p>
<p>Memcached 将内存空间分为一组slab，每个slab里面又包含一组chunk，同一个slab里面的<br>每个chunk的大小是固定的，拥有相同大小的chunk的slab被组织在一起，叫做slab_class，<br>如图所示。</p>
<p>存储数据时根据数据的size大小，寻找一个大于size的最小chunk<br>将数据写入。这种内存管理方式避免了内存碎片的管理问题，内存<br>的分配和释放都是以chunk为单位的。和其他缓存一样，memcached<br>采用LRU算法释放最近最久未被访问的数据占用的空间，释放的<br>chunk被标记为魏永，等待下一个合适大小数据的写入。</p>
<p>当然这种方式也会带来内存浪费的问题。数据只能存入一个比他大的<br>chunk里，而一个chunk只能存一个数据，其他的空间被浪费了。<br>如果启动参数配置不合理，浪费会更加惊人，发现没有缓存多少<br>数据，内存空间就用尽了。</p>
<p><img src="Image.png" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存管理中一个令人头痛的问题就是内存碎片管理。操作系统、虚拟机垃圾回收在这方面&lt;br&gt;想了许多方法：压缩、复制。Memcached使用了一个非常简单的办法—固定空间分配。&lt;/p&gt;
&lt;p&gt;Memcached 将内存空间分为一组slab，每个slab里面又包含一组chunk，同
    
    </summary>
    
      <category term="Memcached" scheme="http://pzhen.github.io/categories/Memcached/"/>
    
    
      <category term="Memcached" scheme="http://pzhen.github.io/tags/Memcached/"/>
    
      <category term="原理" scheme="http://pzhen.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-CONCAT及GROUP_CONCAT</title>
    <link href="http://pzhen.github.io/2017/08/01/Mysql-CONCAT%E5%8F%8AGROUP-CONCAT/"/>
    <id>http://pzhen.github.io/2017/08/01/Mysql-CONCAT及GROUP-CONCAT/</id>
    <published>2017-08-01T03:43:23.000Z</published>
    <updated>2017-08-01T03:46:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、CONCAT（）函数"><a href="#一、CONCAT（）函数" class="headerlink" title="一、CONCAT（）函数"></a>一、CONCAT（）函数</h3><p>CONCAT（）函数用于将多个字符串连接成一个字符串。<br>使用数据表Info作为示例，其中SELECT id,name FROM info LIMIT 1;的返回结果为<br>+—-+——–+<br>| id | name   |<br>+—-+——–+<br>|  1 | BioCyc |<br>+—-+——–+</p>
<h4 id="1、语法及使用特点："><a href="#1、语法及使用特点：" class="headerlink" title="1、语法及使用特点："></a>1、语法及使用特点：</h4><p>CONCAT(str1,str2,…)<br>返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。可以有一个或多个参数。</p>
<h4 id="2、使用示例："><a href="#2、使用示例：" class="headerlink" title="2、使用示例："></a>2、使用示例：</h4><p>SELECT CONCAT(id, ‘，’, name) AS con FROM info LIMIT 1;返回结果为<br>+———-+<br>| con      |<br>+———-+<br>| 1,BioCyc |<br>+———-+</p>
<p>SELECT CONCAT(‘My’, NULL, ‘QL’);返回结果为<br>+————————–+<br>| CONCAT(‘My’, NULL, ‘QL’) |<br>+————————–+<br>| NULL                     |<br>+————————–+</p>
<h4 id="3、如何指定参数之间的分隔符"><a href="#3、如何指定参数之间的分隔符" class="headerlink" title="3、如何指定参数之间的分隔符"></a>3、如何指定参数之间的分隔符</h4><p>使用函数CONCAT_WS（）。使用语法为：CONCAT_WS(separator,str1,str2,…)<br>CONCAT_WS() 代表 CONCAT With Separator ，是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。如果分隔符为 NULL，则结果为 NULL。函数会忽略任何分隔符参数后的 NULL 值。但是CONCAT_WS()不会忽略任何空字符串。 (然而会忽略所有的 NULL）。</p>
<p>如SELECT CONCAT<em>WS(‘</em>‘,id,name) AS con_ws FROM info LIMIT 1;返回结果为<br>+———-+<br>| con_ws   |<br>+———-+<br>| 1_BioCyc |<br>+———-+</p>
<p>SELECT CONCAT_WS(‘,’,’First name’,NULL,’Last Name’);返回结果为<br>+———————————————-+<br>| CONCAT_WS(‘,’,’First name’,NULL,’Last Name’) |<br>+———————————————-+<br>| First name,Last Name                         |<br>+———————————————-+</p>
<h3 id="二、GROUP-CONCAT（）函数"><a href="#二、GROUP-CONCAT（）函数" class="headerlink" title="二、GROUP_CONCAT（）函数"></a>二、GROUP_CONCAT（）函数</h3><p>GROUP_CONCAT函数返回一个字符串结果，该结果由分组中的值连接组合而成。<br>使用表info作为示例，其中语句SELECT locus,id,journal FROM info WHERE locus IN(‘AB086827’,’AF040764’);的返回结果为<br>+———-+—-+————————–+<br>| locus    | id | journal                  |<br>+———-+—-+————————–+<br>| AB086827 |  1 | Unpublished              |<br>| AB086827 |  2 | Submitted (20-JUN-2002)  |<br>| AF040764 | 23 | Unpublished              |<br>| AF040764 | 24 | Submitted (31-DEC-1997)  |<br>+———-+—-+————————–+</p>
<h4 id="1、使用语法及特点："><a href="#1、使用语法及特点：" class="headerlink" title="1、使用语法及特点："></a>1、使用语法及特点：</h4><p>GROUP_CONCAT([DISTINCT] expr [,expr …]<br>[ORDER BY {unsigned_integer | col_name | formula} [ASC | DESC] [,col …]]<br>[SEPARATOR str_val])<br>在 MySQL 中，你可以得到表达式结合体的连结值。通过使用 DISTINCT 可以排除重复值。如果希望对结果中的值进行排序，可以使用 ORDER BY 子句。<br>SEPARATOR 是一个字符串值，它被用于插入到结果值中。缺省为一个逗号 (“,”)，可以通过指定 SEPARATOR “” 完全地移除这个分隔符。<br>可以通过变量 group_concat_max_len 设置一个最大的长度。在运行时执行的句法如下： SET [SESSION | GLOBAL] group_concat_max_len = unsigned_integer;<br>如果最大长度被设置，结果值被剪切到这个最大长度。如果分组的字符过长，可以对系统参数进行设置：SET @@global.group_concat_max_len=40000;</p>
<h4 id="2、使用示例：-1"><a href="#2、使用示例：-1" class="headerlink" title="2、使用示例："></a>2、使用示例：</h4><p>语句 SELECT locus,GROUP_CONCAT(id) FROM info WHERE locus IN(‘AB086827’,’AF040764’) GROUP BY locus; 的返回结果为<br>+———-+——————+<br>| locus    | GROUP_CONCAT(id) |<br>+———-+——————+<br>| AB086827 | 1,2              |<br>| AF040764 | 23,24            |<br>+———-+——————+</p>
<p>语句 SELECT locus,GROUP<em>CONCAT(distinct id ORDER BY id DESC SEPARATOR ‘</em>‘) FROM info WHERE locus IN(‘AB086827’,’AF040764’) GROUP BY locus;的返回结果为<br>+———-+———————————————————-+<br>| locus    | GROUP<em>CONCAT(distinct id ORDER BY id DESC SEPARATOR ‘</em>‘) |<br>+———-+———————————————————-+<br>| AB086827 | 2_1                                                      |<br>| AF040764 | 24_23                                                    |<br>+———-+———————————————————-+</p>
<p>语句SELECT locus,GROUP_CONCAT(concat_ws(‘, ‘,id,journal) ORDER BY id DESC SEPARATOR ‘. ‘) FROM info WHERE locus IN(‘AB086827’,’AF040764’) GROUP BY locus;的返回结果为<br>+———-+————————————————————————–+<br>| locus    | GROUP_CONCAT(concat_ws(‘, ‘,id,journal) ORDER BY id DESC SEPARATOR ‘. ‘) |<br>+———-+————————————————————————–+<br>| AB086827 | 2, Submitted (20-JUN-2002). 1, Unpublished                               |<br>| AF040764 | 24, Submitted (31-DEC-1997) . 23, Unpublished                            |<br>+———-+————————————————————————–+</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、CONCAT（）函数&quot;&gt;&lt;a href=&quot;#一、CONCAT（）函数&quot; class=&quot;headerlink&quot; title=&quot;一、CONCAT（）函数&quot;&gt;&lt;/a&gt;一、CONCAT（）函数&lt;/h3&gt;&lt;p&gt;CONCAT（）函数用于将多个字符串连接成一个字符串。&lt;br
    
    </summary>
    
      <category term="Mysql" scheme="http://pzhen.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://pzhen.github.io/tags/Mysql/"/>
    
      <category term="Concat" scheme="http://pzhen.github.io/tags/Concat/"/>
    
      <category term="Group_concat" scheme="http://pzhen.github.io/tags/Group-concat/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-Datediff()函数</title>
    <link href="http://pzhen.github.io/2017/08/01/Mysql-Datediff-%E5%87%BD%E6%95%B0/"/>
    <id>http://pzhen.github.io/2017/08/01/Mysql-Datediff-函数/</id>
    <published>2017-08-01T03:18:30.000Z</published>
    <updated>2017-08-01T03:21:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>DATEDIFF() 函数返回两个日期之间的天数。</p>
<p>DATEDIFF(date1,date2)</p>
<p>事例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">SELECT</span> *</div><div class="line"><span class="keyword">FROM</span> con_contract</div><div class="line"><span class="keyword">WHERE</span></div><div class="line">    <span class="keyword">datediff</span>(</div><div class="line">        FROM_UNIXTIME(remindtime, <span class="string">'%Y-%m-%d'</span>),<span class="keyword">CURDATE</span>()</div><div class="line">    ) = &#123;$limit_time&#125; <span class="keyword">and</span> state = <span class="number">3</span> <span class="keyword">and</span> archivestate &lt;&gt; <span class="number">4</span> <span class="keyword">and</span> archivestate &lt;&gt; <span class="number">5</span><span class="string">";</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DATEDIFF() 函数返回两个日期之间的天数。&lt;/p&gt;
&lt;p&gt;DATEDIFF(date1,date2)&lt;/p&gt;
&lt;p&gt;事例：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;di
    
    </summary>
    
      <category term="Mysql" scheme="http://pzhen.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://pzhen.github.io/tags/Mysql/"/>
    
      <category term="Datediff" scheme="http://pzhen.github.io/tags/Datediff/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-Int类型</title>
    <link href="http://pzhen.github.io/2017/07/31/Mysql-Int%E7%B1%BB%E5%9E%8B/"/>
    <id>http://pzhen.github.io/2017/07/31/Mysql-Int类型/</id>
    <published>2017-07-31T10:04:20.000Z</published>
    <updated>2017-08-01T02:11:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>几种整形数据类型的长度</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><pre><code>类型            占用空间(字节)        最小值(带符号的/无符号的)                最大值(带符号的/无符号的)
----------------------------------------------------------------------------------------------------
TINYINT        1                    -128                                127
                                0                                    255
----------------------------------------------------------------------------------------------------
SMALLINT    2                    -32768                                32767
                                0                                    65535
----------------------------------------------------------------------------------------------------
MEDIUMINT    3                    -8388608                            8388607
                                0                                    16777215
----------------------------------------------------------------------------------------------------
int            4                    -2147483648                            2147483647
                                0                                    4294967295
----------------------------------------------------------------------------------------------------
BIGINT        8                    -9223372036854775808                9223372036854775807
                                0                                    18446744073709551615
----------------------------------------------------------------------------------------------------
注:1字节=8位
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几种整形数据类型的长度&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://pzhen.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://pzhen.github.io/tags/Mysql/"/>
    
      <category term="Int" scheme="http://pzhen.github.io/tags/Int/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-Varchar类型</title>
    <link href="http://pzhen.github.io/2017/07/31/Mysql-Varchar%E7%B1%BB%E5%9E%8B/"/>
    <id>http://pzhen.github.io/2017/07/31/Mysql-Varchar类型/</id>
    <published>2017-07-31T10:01:18.000Z</published>
    <updated>2017-07-31T10:06:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>1.varchar存储规则：<br>    5.0版本以上，varchar(20)，指的是20字符，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放20个.<br>    上面测试过了如果超过20个字符mysql截取前20个插入<br>    但是 最大大小是65532字节 也就是 varchar字节最大65535，utf8编码一个字符3个字节65535/3=21785。汉字不能超过21785.</p>
<p>2.关于varchar与set 类型中存储的字符串使用’,’隔开时<br>    可以采用:SELECT * FROM <code>表名</code> WHERE FIND_IN_SET(‘要找的字符串’,<code>字段</code>);这种写法来找出;<br>    最多可以有64个成员  枚举最多有65535种不同值</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;1.varchar存储规则：&lt;br&gt;    5.0版本以上，varchar(20)，指的是20字符，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放20个.&lt;br&gt;    上面测试过了如果超过20个字符mysql截取前20个插入
    
    </summary>
    
      <category term="Mysql" scheme="http://pzhen.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://pzhen.github.io/tags/Mysql/"/>
    
      <category term="Varchar" scheme="http://pzhen.github.io/tags/Varchar/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-蠕虫复制</title>
    <link href="http://pzhen.github.io/2017/07/31/Mysql-%E8%A0%95%E8%99%AB%E5%A4%8D%E5%88%B6/"/>
    <id>http://pzhen.github.io/2017/07/31/Mysql-蠕虫复制/</id>
    <published>2017-07-31T09:22:04.000Z</published>
    <updated>2017-07-31T09:23:19.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`table`</span> (<span class="string">`id`</span>,<span class="string">`aa`</span>,<span class="string">`bb`</span>,<span class="string">`cc`</span> ) <span class="keyword">SELECT</span> <span class="string">''</span>,<span class="string">'aa内容'</span>,<span class="string">'bb注意cc符号区别'</span>,<span class="string">`cc`</span> <span class="keyword">FROM</span> <span class="string">`table`</span> (<span class="keyword">WHERE</span> .....)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;
    
    </summary>
    
      <category term="Mysql" scheme="http://pzhen.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://pzhen.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-开启日志</title>
    <link href="http://pzhen.github.io/2017/07/31/Mysql-%E5%BC%80%E5%90%AF%E6%97%A5%E5%BF%97/"/>
    <id>http://pzhen.github.io/2017/07/31/Mysql-开启日志/</id>
    <published>2017-07-31T09:18:58.000Z</published>
    <updated>2017-07-31T09:20:36.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line"></div><div class="line">port=3306</div><div class="line">log=D:/mysql.log</div><div class="line">log_slow_queries=C:/temp/mysql_slow.log</div><div class="line">long_query_time=1</div></pre></td></tr></table></figure>
<p>show binary logs;</p>
<p>//查看binlog日志<br>show binlog events in ‘mysql-bin.000181’;</p>
<p>查看日志是否开启<br>1).可以通过Mysql配置文件my.cnf来确认（Mysql默认开启二进制日志记录）：<br>Replication Master Server (default)<br>binary logging is required for replication<br>log-bin=mysql-bin<br>刷新日志<br>flush logs;<br>查看当前日志位置<br>show master status;<br>查看当前所有日志<br>show master logs;<br>清空所有的bin-log日志<br>reset master;</p>
<p>查看日志内容<br>mysqlbinlog –no-defaults mysql-bin.00001;<br>删除bin-log<br>mysql&gt; purge binary logs to ‘ablelee.000003’;<br>Query OK, 0 rows affected (0.16 sec)<br>关闭 bin-log 日志<br>找到配置文件my.cnf，对于linux，一般默认在/etc目录下，打开此文件，使用井号(#)注释掉如下两个配置项目即可。<br>log-bin=mysql-bin<br>binlog_format=mixed<br>显示所有日志<br>mysql&gt; show binary logs;</p>
<p>//查看所有日志<br>show binary logs;<br>//查看正在使用的binlog<br>show master status;</p>
<p>purge binary logs to ‘mysql-tb-bin.000005’;<br>这个命令就是清理除mysql-tb-bin.000005以外的其他二进制日志；</p>
<p>//查看binlog日志<br>show binlog events in ‘mysql-bin.000181’;</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
    
    </summary>
    
      <category term="Mysql" scheme="http://pzhen.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://pzhen.github.io/tags/Mysql/"/>
    
      <category term="日志" scheme="http://pzhen.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Php 一phpStorm快捷键</title>
    <link href="http://pzhen.github.io/2017/07/31/Php-phpStorm%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://pzhen.github.io/2017/07/31/Php-phpStorm快捷键/</id>
    <published>2017-07-31T08:35:26.000Z</published>
    <updated>2017-07-31T08:37:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在把一些使用技巧记录下来,免得到时候忘了再查.</p>
<p>来源于网络。</p>
<a id="more"></a>
<p>1,从版本控制系统创建项目:<br>CVS -&gt; Checkout from Version Control</p>
<p>2, 关联DOC文档:<br>右键External Librariese -&gt; Configure PHP include paths</p>
<p>3, 去掉波浪线:<br>settings -&gt; Editor -&gt; Colors &amp; Fonts -&gt; General -&gt; TYPO-&gt;Effects</p>
<p>4, 显示行号:<br>settings -&gt; Editor-&gt;Appearance-&gt;Show line numbers </p>
<p>5,远程或本地同步文件:<br>Tools -&gt; Deploments -&gt; Configuration</p>
<p>6, 去掉右上角浏览器图标:<br>settings -&gt; tools -&gt; WebBrowsers</p>
<p>7, 添加VIM插件:<br>settings-&gt;editor -&gt;plugins-&gt;browse repositories -&gt;搜索VIM</p>
<p>8,启动的时候不打开工程文件<br>Settings-&gt;General去掉Reopen last project on startup.</p>
<p>9, 取消自动保存<br>appearance -&gt; system settings -&gt; save file的两个选项 去掉</p>
<p>10, 将编辑的文件加星号标识:<br>settings -&gt; editor -&gt; editor tabs -&gt; 勾选 mark modifed tabs…</p>
<p>11, 添加扩展名高亮显示:<br>settings -&gt; editor -&gt; file types  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">常用快捷键:</div><div class="line">control + option + l    将代码格式化</div><div class="line">command + shift + u    切换大小写</div><div class="line">command + shift + + / command + shift + -     折叠/展开所有区块</div><div class="line">command + e     列出最后打开的文件</div><div class="line">control + tab  / control + shift + tab     切换打开的文件</div><div class="line">command + /     行注释</div><div class="line">ctrl + shift + /      块注释</div><div class="line">command + b     函数追踪,同command +单击</div><div class="line">command + alt + 左右箭头      操作动作前进/回退</div><div class="line">shift + command + r      按文件名搜索对应文件所在路径</div><div class="line">shift + command + t      按类名搜索对应文件所在路径</div><div class="line">shift + command + c      复制当前文件所在路径</div><div class="line">Command + Shift + O     打开文件</div><div class="line">Command + O          打开类</div><div class="line">alt + F1        定位编辑文件所在位置:</div><div class="line">alt + F12        打开命令行栏</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在把一些使用技巧记录下来,免得到时候忘了再查.&lt;/p&gt;
&lt;p&gt;来源于网络。&lt;/p&gt;
    
    </summary>
    
      <category term="Php" scheme="http://pzhen.github.io/categories/Php/"/>
    
    
      <category term="Php" scheme="http://pzhen.github.io/tags/Php/"/>
    
      <category term="PhpStorm" scheme="http://pzhen.github.io/tags/PhpStorm/"/>
    
  </entry>
  
  <entry>
    <title>Shell – Wget 克隆网站</title>
    <link href="http://pzhen.github.io/2017/07/31/Shell-%E2%80%93-Wget-%E5%85%8B%E9%9A%86%E7%BD%91%E7%AB%99%E5%88%B0%E6%9C%AC%E5%9C%B0/"/>
    <id>http://pzhen.github.io/2017/07/31/Shell-–-Wget-克隆网站到本地/</id>
    <published>2017-07-31T08:14:22.000Z</published>
    <updated>2017-07-31T08:18:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候觉得网上看到的漂亮的模板，想下载怎么办哈哈哈wget就搞定了。</p>
<a id="more"></a>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -k -p -nH -N http://www.baidu.com</div></pre></td></tr></table></figure>
<p>-k   把已下载文件中的所有链接都转换为本地引用，不在依赖原始或在线内容</p>
<p>-p   下载所有必要文件，确保离线可用，包括图片和样式表</p>
<p>-nH  禁止把文件下载到以主机名为前缀的文件夹中。</p>
<p>-N   启用文件的时间戳,以匹配来源的时间戳.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候觉得网上看到的漂亮的模板，想下载怎么办哈哈哈wget就搞定了。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://pzhen.github.io/categories/Linux/"/>
    
      <category term="Shell" scheme="http://pzhen.github.io/categories/Linux/Shell/"/>
    
    
      <category term="Linux" scheme="http://pzhen.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="http://pzhen.github.io/tags/Shell/"/>
    
      <category term="Wget" scheme="http://pzhen.github.io/tags/Wget/"/>
    
  </entry>
  
  <entry>
    <title>Php 一Api通信规则</title>
    <link href="http://pzhen.github.io/2017/07/31/Php-Api%E9%80%9A%E4%BF%A1%E8%A7%84%E5%88%99/"/>
    <id>http://pzhen.github.io/2017/07/31/Php-Api通信规则/</id>
    <published>2017-07-31T07:34:52.000Z</published>
    <updated>2017-07-31T07:53:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Api 通信中，可以采用非对称加密的方式，来提高安全性，也可以采用，下面的通信规则。</p>
<p>如果采用下面方式，可以将时间戳取前7位有效数字来加密这样每隔十几分钟MD5<br>就一换，还能避开服务器时间不同步问题，也是不错的选择。</p>
<a id="more"></a>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *生成THQS算法的信息查询串（Query string）</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">get_query_string</span><span class="params">($info)</span> </span>&#123;</div><div class="line">    ksort($info);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;http_build_query($info);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 根据数组生成HTTP请求URL参数</div><div class="line"> * <span class="doctag">@param</span> unknown_type $array</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">http_build_query</span><span class="params">($array)</span> </span>&#123;</div><div class="line">    $query = <span class="string">''</span>;</div><div class="line">    <span class="keyword">foreach</span> ($array <span class="keyword">as</span> $key =&gt; $value) &#123;</div><div class="line">        $key = <span class="keyword">self</span>::urlencode($key);</div><div class="line">        $value = <span class="keyword">self</span>::urlencode($value);</div><div class="line">        $query .= <span class="string">"$key=$value&amp;"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (strlen($query)) &#123;</div><div class="line">        $query = substr($query, <span class="number">0</span>, <span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> $query;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * *不要被转义了。</div><div class="line"> * <span class="doctag">@param</span> $string</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">urlencode</span><span class="params">($string)</span> </span>&#123;</div><div class="line">    $string = str_replace(<span class="string">'*'</span>, <span class="string">'-tSl2nWmMsagD-gEr'</span>, $string);</div><div class="line">    $string = urlencode($string);</div><div class="line">    <span class="keyword">return</span> str_replace(<span class="string">'-tSl2nWmMsagD-gEr'</span>, <span class="string">'*'</span>, $string);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 	生成THQS算法的hash值</div><div class="line"> *  $salt = API Key 秘钥</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">get_hashed_value</span><span class="params">($qs, $time, $salt)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> strtoupper(md5($qs . <span class="string">"&amp;time=$time&amp;salt=$salt"</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> *	return string</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">ccXml</span><span class="params">()</span></span>&#123;</div><div class="line">    header(<span class="string">'Content-Type:text/xml'</span>);</div><div class="line">    $str = <span class="string">''</span>;</div><div class="line">    $str .= <span class="string">"&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n"</span>;</div><div class="line">    $str .= <span class="string">"&lt;result&gt;OK&lt;/result&gt;"</span>;</div><div class="line">    <span class="keyword">return</span> $str;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Api 通信中，可以采用非对称加密的方式，来提高安全性，也可以采用，下面的通信规则。&lt;/p&gt;
&lt;p&gt;如果采用下面方式，可以将时间戳取前7位有效数字来加密这样每隔十几分钟MD5&lt;br&gt;就一换，还能避开服务器时间不同步问题，也是不错的选择。&lt;/p&gt;
    
    </summary>
    
      <category term="Php" scheme="http://pzhen.github.io/categories/Php/"/>
    
    
      <category term="Php" scheme="http://pzhen.github.io/tags/Php/"/>
    
      <category term="Api" scheme="http://pzhen.github.io/tags/Api/"/>
    
  </entry>
  
  <entry>
    <title>Composer - 管理PHP依赖</title>
    <link href="http://pzhen.github.io/2017/07/21/Composer-%E7%AE%A1%E7%90%86PHP%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/"/>
    <id>http://pzhen.github.io/2017/07/21/Composer-管理PHP依赖关系/</id>
    <published>2017-07-21T09:32:30.000Z</published>
    <updated>2017-07-22T08:30:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>现在软件规模越来越大，PHP项目的开发模式和许多年前已经有了很大变化。记得初学PHP那会儿，boblog是一个很好的例子，几乎可以代表 PHP项目的开发模式。当时PHP 5.x以上的版本刚开始流行，仍然有大量的生产环境使用PHP4.x。由于历史遗留的问题，OOP思想在PHP项目中还不是那么广泛流行。随着 PHP5.3的发布，PHP项目规模的扩大，在其他语言领域大展身手的OOP开发模式也在PHP中崭露头角。<br><a id="more"></a><br>大型项目不可能是从头开始的，使用社区已经提供的资源可以为项目带来很大的便利。然而各自为政的打包方式、依赖关系的处理，导致了很难将两个开源项 目集成到一起。虽然有pear这种PHP官方支持的包管理工具，但是依然没有很好的统一的依赖关系管理的办法。直到Composer的出现。</p>
<p>Composer的依赖关系管理风格，看上去更像Java的Maven。项目编译和打包、依赖关系的解决都可以很轻松的实现。再也不用费神去寻找或者更新第三方库，或者将他们集成到一起。这一切全部都可以交给Composer来完成。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>首先来看一个类似于Helloworld的例子，让我们对Composer先有一个感性的认识吧。</p>
<p>如何在一个PHP项目中启用Composer，很简单，只需要在项目根目录中创建一个composer.json文件即可，它包含如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        &quot;require&quot;: &#123;</div><div class="line">	        &quot;monolog/monolog&quot;: &quot;1.2.*&quot;</div><div class="line">	 &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样我们便添加了对monolog这个库的引用。没错，就是这样简单。不过，你还需要使用composer来为你更新依赖包，打开你的Shell，切换到项目目录下执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">composer install</div></pre></td></tr></table></figure></p>
<p>这时，Composer便自动从互联网上更新指定依赖的库了。你会发现你的项目文件夹里面多了一个vendor文件夹，那就是依赖库包了。</p>
<p>接下来，你需要在你的系统的公共入口文件中引用自动加载器，以便自动加载类：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'vendor/autoload.php'</span>;</div></pre></td></tr></table></figure></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>上面的例子让大家对composer的使用有了一个大概的认识。下面将向大家介绍如何在PHP环境中安装composer。<br>Unix/Linux/OSX环境</p>
<p>很幸运，利用Unix Like环境安装composer是一件很简单的事情。只需要一行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -sS https://getcomposer.org/installer | php</div></pre></td></tr></table></figure></p>
<p>此时会为你在当前工作目录安装composer.phar文件，使用php composer.phar即可运行。当然，你可能更想让composer变成像其他一样的Unix命令，很简单，只需要再加一步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mv composer.phar /usr/local/bin/composer</div></pre></td></tr></table></figure></p>
<p>注意，在权限受限的系统上，你可能需要使用sudo命令来提升至管理员账号执行。</p>
<p>这时，你就可以像例子里面那样使用composer了。<br>Windows环境</p>
<p>Composer官方推荐使用安装包进行安装，据说下载Composer-Setup.exe这个即可用向导模式安装。</p>
<p>关于手工安装的方法，请参考<a href="http://getcomposer.org/doc/00-intro.md的介绍吧。" target="_blank" rel="external">http://getcomposer.org/doc/00-intro.md的介绍吧。</a></p>
<h4 id="自动加载"><a href="#自动加载" class="headerlink" title="自动加载"></a>自动加载</h4><p>为了实现PHP类的随取随用，类的命名空间定义建议遵从一定的规则。这种规则可以是某一项目组约定的。不过为了使得类库统一，PHP-FIG项目指 定了一种PHP命名空间的规范PSR-0，被一些流行PHP项目采用。Composer支持这种规范的类库自动装载器，只需要向 composer.json文件中添加autoload节点即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	    &quot;autoload&quot;: &#123;</div><div class="line">	        &quot;psr-0&quot;: &#123;&quot;Acme\\&quot;: &quot;src/&quot;&#125;</div><div class="line">	    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于PSR-0规范，有这么几点重要的要求：</p>
<ul>
<li>命名空间规范参考：\<vendor name="">(<namespace>)*<class name=""></class></namespace></vendor></li>
<li>每个namespace需要一个顶层空间，即vendor name。用来指定在软件包级别上区别。</li>
<li>命名空间和PHP文件的路径是一一对应的，最终命名空间分隔符会被转为DIRECTORY_SEPARATOR</li>
<li>文件名必须为类名.php</li>
</ul>
<p>关于这个规范，可以参考<a href="http://blog.mosil.biz/2012/08/psr-0-autoloading-standard/这篇文章。有关PSR-0的更多内容，可以参考他们的官方网站：https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md" target="_blank" rel="external">http://blog.mosil.biz/2012/08/psr-0-autoloading-standard/这篇文章。有关PSR-0的更多内容，可以参考他们的官方网站：https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md</a></p>
<p>注意，修改了autoload后，要重新使用composer install。</p>
<p>注意：composer默认类库是使用PSR-0规范自动加载的。所以一般无需额外配置。</p>
<h4 id="查找所需类库"><a href="#查找所需类库" class="headerlink" title="查找所需类库"></a>查找所需类库</h4><p>composer提供了一个类库的“商店”，在这里，你可以立即找到想要使用的开源类库包，然后把他们添加到你的项目中即可。传送门：<a href="https://packagist.org/" target="_blank" rel="external">https://packagist.org/</a></p>
<h4 id="打包自己的类库"><a href="#打包自己的类库" class="headerlink" title="打包自己的类库"></a>打包自己的类库</h4><p>将自己的类库贡献给大家，首先需要为自己的类库设置打包信息（要首先保证自己的类库是利用composer管理的）。在composer.json文件中设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name&quot;: &quot;your-vendor-name/package-name&quot;,</div><div class="line">    &quot;require&quot;: &#123;</div><div class="line">        &quot;php&quot;: &quot;&gt;=5.3.0&quot;,</div><div class="line">        &quot;another-vendor/package&quot;: &quot;1.*&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后就可以前去<a href="https://packagist.org/提交你的类库了。" target="_blank" rel="external">https://packagist.org/提交你的类库了。</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="http://getcomposer.org/doc/00-intro.md" target="_blank" rel="external">快速入门</a></li>
<li><a href="http://getcomposer.org/doc/" target="_blank" rel="external">文档</a></li>
<li><a href="https://packagist.org/" target="_blank" rel="external">包列表</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;现在软件规模越来越大，PHP项目的开发模式和许多年前已经有了很大变化。记得初学PHP那会儿，boblog是一个很好的例子，几乎可以代表 PHP项目的开发模式。当时PHP 5.x以上的版本刚开始流行，仍然有大量的生产环境使用PHP4.x。由于历史遗留的问题，OOP思想在PHP项目中还不是那么广泛流行。随着 PHP5.3的发布，PHP项目规模的扩大，在其他语言领域大展身手的OOP开发模式也在PHP中崭露头角。&lt;br&gt;
    
    </summary>
    
      <category term="Composer" scheme="http://pzhen.github.io/categories/Composer/"/>
    
    
      <category term="Composer" scheme="http://pzhen.github.io/tags/Composer/"/>
    
      <category term="Php" scheme="http://pzhen.github.io/tags/Php/"/>
    
  </entry>
  
  <entry>
    <title>Shell – 正则表达式</title>
    <link href="http://pzhen.github.io/2017/07/21/Shell-%E2%80%93-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://pzhen.github.io/2017/07/21/Shell-–-正则表达式/</id>
    <published>2017-07-21T09:00:23.000Z</published>
    <updated>2017-07-21T09:02:57.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="正则表达式的分类"><a href="#正则表达式的分类" class="headerlink" title="正则表达式的分类"></a>正则表达式的分类</h4><ul>
<li>基本的正则表达式（Basic Regular Expression 又叫Basic RegEx 简称BREs）</li>
<li>扩展的正则表达式（Extended Regular Expression 又叫Extended RegEx 简称EREs）</li>
<li>Perl的正则表达式（Perl Regular Expression 又叫Perl RegEx 简称PREs）</li>
</ul>
<h4 id="基本组成部分"><a href="#基本组成部分" class="headerlink" title="基本组成部分"></a>基本组成部分</h4><p>正则表达式的基本组成部分。</p>
<p><img src="WX20170517-1442082x.png" alt="image"></p>
<h4 id="POSIX字符类"><a href="#POSIX字符类" class="headerlink" title="POSIX字符类"></a>POSIX字符类</h4><p>POSIX字符类是一个形如[:…:]的特殊元序列（meta sequence），他可以用于匹配特定的字符范围。</p>
<p><img src="WX20170517-1440442x.png" alt="image"></p>
<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><p>元字符（meta character）是一种Perl风格的正则表达式，只有一部分文本处理工具支持它，并不是所有的文本处理工具都支持。</p>
<p><img src="WX20170517-1443312x.png" alt="image"></p>
<p>文章来源：<a href="http://man.linuxde.net/docs/shell_regex.html" target="_blank" rel="external">http://man.linuxde.net/docs/shell_regex.html</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;正则表达式的分类&quot;&gt;&lt;a href=&quot;#正则表达式的分类&quot; class=&quot;headerlink&quot; title=&quot;正则表达式的分类&quot;&gt;&lt;/a&gt;正则表达式的分类&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;基本的正则表达式（Basic Regular Expression 又叫Basi
    
    </summary>
    
      <category term="Linux" scheme="http://pzhen.github.io/categories/Linux/"/>
    
      <category term="Shell" scheme="http://pzhen.github.io/categories/Linux/Shell/"/>
    
    
      <category term="Shell" scheme="http://pzhen.github.io/tags/Shell/"/>
    
      <category term="正则" scheme="http://pzhen.github.io/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
</feed>
